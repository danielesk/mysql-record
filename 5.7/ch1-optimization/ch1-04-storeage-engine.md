# 优化InnoDB表(Optimizing for InnoDB Tables)

InnoDB是MySQL客户通常在生产数据库中使用的存储引擎，在生产数据库中，可靠性和并发性非常重要。InnoDB是MySQL中的默认存储引擎。本节解释如何优化InnoDB表的数据库操作。

## 4.1 优化InnoDB表的存储布局

- 一旦数据达到稳定的大小，或者正在增长的表增加了几十或几百兆字节，考虑使用`OPTIMIZE TABLE`语句重新组织表并压缩任何浪费的空间。重新组织的表执行全表扫描所需的磁盘I/O更少。这是一种简单的技术，可以在其他技术(如改进索引使用或调优应用程序代码)不实用时提高性能。
`OPTIMIZE TABLE`复制表的数据部分并重新构建索引。好处在于改进了索引中的数据打包，减少了表空间和磁盘上的碎片。这些好处取决于每个表中的数据。您可能会发现，对某些表有显著的收益，而对其他表没有，或者随着时间的推移，收益会减少，直到下一次优化表为止。如果表很大，或者正在重建的索引不适合缓冲池，则此操作可能很慢。向表中添加大量数据后的第一次运行通常比第一次运行慢得多

- 在InnoDB中，拥有一个长`PRIMARY KEY`(要么是一个长值的列，要么是多个组成长复合值的列)会浪费大量磁盘空间。行的主键值在指向同一行的所有辅助索引记录中重复。如果主键长，则创建一个`AUTO_INCREMENT`列作为主键，或者索引一个长`VARCHAR`列的前缀，而不是整个列。

- 使用`VARCHAR`数据类型而不是`CHAR`来存储可变长度的字符串或具有多个列的列`NULL`值。`CHAR(N)`列总是使用`N`个字符来存储数据，即使字符串更短或其值为`NULL`。较小的表更适合放在缓冲池中，并减少磁盘I/O。
当使用`COMPACT`行格式(默认的`InnoDB`格式)和可变长度字符集(如`utf8`或`sjis`)时，`CHAR(N)`列会占用可变的空间，但仍然至少占用`N`个字节。

- 对于较大的表或包含大量重复文本或数字数据的表，请考虑使用`COMPRESSED`行格式。将数据放入缓冲池或执行全表扫描需要较少的磁盘I/O.在做出永久性决策之前，请使用`COMPRESSED`与`COMPACT`行格式测量可以实现的压缩量。


## 4.2 优化InnoDB事务管理

要优化`InnoDB`事务处理，请在事务特性的性能开销和服务器的工作负载之间找到理想的平衡。例如，如果应用程序每秒提交数千次，则可能会遇到性能问题;如果仅每2-3小时提交一次，则可能会遇到不同的性能问题。

- 默认的MySQL设置`AUTOCOMMIT=1`会对繁忙的数据库服务器造成性能限制。如果可行，通过发出`SET AUTOCOMMIT=0`或`START transaction`语句，将几个相关的数据更改操作封装到一个事务中，然后在进行所有更改之后发出`COMMIT`语句。
如果事务对数据库进行了修改，InnoDB必须在每次事务提交时将日志刷新到磁盘。当每次更改之后都进行提交(与默认的自动提交设置一样)时，存储设备的I/O吞吐量为每秒潜在操作的数量设置了上限。

- 或者，对于仅包含单个SELECT语句的事务，启用`AUTOCOMMIT`可帮助InnoDB识别只读事务并对其进行优化。

- 避免在插入、更新或删除大量行之后执行回滚。如果一个大事务正在降低服务器性能，那么回滚它会使问题变得更糟，可能需要比原始数据更改操作多几倍的时间来执行。终止数据库进程没有帮助，因为回滚在服务器启动时再次启动。

为了尽量减少发生这种情况的机会:

- 增加 `buffer pool` 的大小，以便所有数据更改更改都可以缓存，而不是立即写入磁盘。

- 设置`innodb_change_buffering=all`，以便除了插入操作之外，更新和删除操作也得到缓冲。

- 考虑在大数据更改操作期间定期发出`COMMIT`语句，可能将单个delete或update语句分解为多个语句，这些语句操作的行数更少。


要在发生失控回滚后摆脱它，请增加缓冲池以使回滚变为CPU限制并快速运行，或者终止服务器并使用`innodb_force_recovery = 3`重新启动。

在默认设置`innodb_change_buffering=all`的情况下，这个问题预计不会经常发生，因为默认设置允许将更新和删除操作缓存在内存中，这使得它们首先执行起来更快，如果需要，回滚也更快。确保在处理具有许多插入、更新或删除操作的长时间运行的事务的服务器上使用此参数设置。


- 如果在发生崩溃时，您能够承受一些最新提交事务的损失，那么可以将`innodb_flush_log_at_trx_commit`参数设置为`0`。InnoDB尝试每秒刷新一次日志，尽管不能保证刷新。另外，将`innodb_support_xa`的值设置为`0`，这将减少由于同步磁盘数据和二进制日志而导致的磁盘刷新次数。


`注意`
`innodb_support_xa`已被弃用，将在将来的版本中删除。从MySQL 5.7.10开始，InnoDB始终支持`XA`事务中的两阶段提交，不再允许禁用`innodb_support_xa`。
`注意`


- 当修改或删除行时，不会立即物理地删除行和相关的 `undo logs`，甚至在事务提交之后也不会立即删除。旧数据将保存到较早启动或并发的事务完成之前，以便这些事务可以访问修改或删除行之前的状态。因此，长时间运行的事务可以防止InnoDB清除由不同事务更改的数据。


- 在长时间运行的事务中修改或删除行时，使用`READ COMMITTED`和`REPEATABLE READ`隔离级别的其他事务必须执行更多工作，以便在读取相同行时重建旧数据。

- 当长时间运行的事务修改表时，其他事务对该表的查询不使用 `covering index` 技术。通常可以从辅助索引检索所有结果列的查询，而是从表数据中查找适当的值。


如果发现辅助索引页的`PAGE_MAX_TRX_ID`太新，或者辅助索引中的记录被删除，InnoDB可能需要使用聚集索引查找记录。


## 4.3 优化InnoDB只读事务

InnoDB可以避免为已知为只读的事务设置事务ID (`TRX_ID`字段)所带来的开销。只有可能执行写操作或锁定读取的事务（例如`SELECT ... FOR UPDATE`）才需要事务ID。消除不必要的事务id可以减少每次查询或数据更改语句构造读取视图时所查询的内部数据结构的大小。

InnoDB检测只读事务时:

- 事务用`START transaction READ ONLY`语句启动。在这种情况下，试图更改数据库(针对InnoDB、MyISAM或其他类型的表)会导致错误，事务将继续处于只读状态:

```mysql
ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.
```

您仍然可以在只读事务中更改特定于会话的临时表，或者对它们发出锁定查询，因为这些更改和锁定对任何其他事务都不可见。

- `autocommit`设置已打开，因此事务保证是单个语句，构成事务的单个语句是“非锁定”SELECT语句。 也就是说，SELECT不使用`FOR UPDATE`或`LOCK IN SHARED MODE`子句。

- 事务在没有READ ONLY选项的情况下启动，但是还没有执行显式锁定行的更新或语句。除非需要更新或显式锁，否则事务将保持只读模式。

因此，对于读取密集型应用程序（如报表生成器），可以通过在`START TRANSACTION READ ONLY`和`COMMIT`中对它们进行分组来调整InnoDB查询序列，或者在运行SELECT语句之前打开自动提交设置，或者简单地避免 任何数据更改语句穿插在查询中。

`注意`
符合自动提交，非锁定和只读（AC-NL-RO）的事务不在某些内部InnoDB数据结构之外，因此未在SHOW ENGINE INNODB STATUS输出中列出。
`注意`


## 4.4 优化InnoDB重做日志

考虑以下优化重做日志的准则:

- 让重做日志文件变大，甚至和`buffer pool`一样大。当InnoDB已将重做日志文件写满时，它必须将缓冲池的修改内容写入`checkpoint`中的磁盘。小型重做日志文件会导致许多不必要的磁盘写操作。尽管历史上大型重做日志文件会导致较长的恢复时间，但现在恢复速度要快得多，您可以放心地使用大型重做日志文件。

使用`innodb_log_file_size`和`innodb_log_files_in_group`配置选项配置重做日志文件的大小和数量。

- 考虑增加日志缓冲区的大小。大型日志缓冲区允许运行大型事务，而不需要在事务提交之前将日志写入磁盘。因此，如果您有更新、插入或删除许多行的事务，使日志缓冲区变大可以节省磁盘I/O。日志缓冲区大小是使用`innodb_log_buffer_size`配置选项配置的。

- 配置`innodb_log_write_ahead_size`配置选项以避免`“read-on-write”`。 此选项定义重做日志的预写块大小。设置`innodb_log_write_ahead_size`以匹配操作系统或文件系统缓存块大小。由于重做日志的预写块大小与操作系统或文件系统高速缓存块大小不匹配，重做日志块未完全高速缓存到操作系统或文件系统时，会发生`“read-on-write”`。

`innodb_log_write_ahead_size`的有效值是InnoDB日志文件块大小(`2^n`)的倍数。最小值是InnoDB日志文件块大小(`512`)。当指定最小值时，不会发生预写。最大值等于`innodb_page_size`值。如果为`innodb_log_write_ahead_size`指定一个大于`innodb_page_size`值的值，`innodb_log_write_ahead_size`设置将被截断为`innodb_page_size`值。


将`innodb_log_write_ahead_size`值设置得过低，与操作系统或文件系统缓存块大小相关，会导致读写。将该值设置得过高可能会对日志文件写入的`fsync`性能产生轻微影响，因为要同时写入多个块。


## 4.5 InnoDB表的批量数据加载

- 当将数据导入InnoDB时，关闭自动提交模式，因为每次插入都会执行一次磁盘日志刷新。要在导入操作期间禁用自动提交，请用`SET autocommit`和`COMMIT`语句包围它:

```mysql
SET autocommit=0;
... SQL import statements ...
COMMIT;
```

`mysqldump`选项`--opt`创建转储文件，这些文件可以快速导入到InnoDB表中，即使不使用`SET autocommit`和`COMMIT`语句包装它们。

- 如果你对辅助键有`UNIQUE`的限制，你可以通过在导入过程中暂时关闭唯一性检查来加快表的导入:

```mysql
SET unique_checks=0;
... SQL import statements ...
SET unique_checks=1;
```

对于大表，这节省了大量磁盘I/O，因为InnoDB可以使用它的更改缓冲区在批处理中编写辅助索引记录。确保数据不包含重复的键。

- 如果表中有`FOREIGN KEY`约束，可以在导入会话期间关闭外键检查，从而加快表的导入:

```mysql
SET foreign_key_checks=0;
... SQL import statements ...
SET foreign_key_checks=1;
```

对于大表，这可以节省大量磁盘I/O。

- 如果需要 INSERT 多行，请使用多行插入语法来减少客户机和服务器之间的通信开销:

```mysql
INSERT INTO yourtable VALUES (1,2), (5,5), ...;
```

这个技巧适用于插入任何表，而不仅仅是InnoDB表。

- 在使用自动递增列对表进行批量插入时，将`innodb_autoinc_lock_mode`设置为`2`，而不是默认值`1`。

- 执行批量插入时，以`PRIMARY KEY`顺序插入行会更快。 InnoDB表使用聚簇索引，这使得以`PRIMARY KEY`的顺序使用数据相对较快。以`PRIMARY KEY`顺序执行批量插入对于不完全适合缓冲池的表尤为重要。

- 在将数据加载到`InnoDB`全文索引时，要获得最佳性能，请遵循以下步骤:

1. 表创建时定义一个列`FTS_DOC_ID`，类型为`BIGINT UNSIGNED NOT NULL`，具有一个名为`FTS_DOC_ID_INDEX`的惟一索引。例如:

```mysql
CREATE TABLE t1 (
FTS_DOC_ID BIGINT unsigned NOT NULL AUTO_INCREMENT,
title varchar(255) NOT NULL DEFAULT '',
text mediumtext NOT NULL,
PRIMARY KEY (`FTS_DOC_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on t1(FTS_DOC_ID);
```

2. 将数据加载到表中。

3. 在加载数据之后创建`FULLTEXT`。

`注意`
在创建表时添加`FTS_DOC_ID`列时，请确保在更新`FULLTEXT`索引列时更新`FTS_DOC_ID`列，因为`FTS_DOC_ID`必须随每个`INSERT`或`UPDATE`单调增加。 如果您选择不在创建表时添加`FTS_DOC_ID`并让`InnoDB`为您管理`DOC ID`，`InnoDB`将使用下一个`CREATE FULLTEXT INDEX`调用将`FTS_DOC_ID`添加为隐藏列。 但是，这种方法需要进行表重建，这会影响性能。
`注意`


## 4.6 优化InnoDB查询

要调优`InnoDB`表的查询，请在每个表上创建一组适当的索引。

- 因为每个`InnoDB`表都有一个主键(无论您是否请求主键)，所以为每个表指定一组主键列，这些列用于最重要和时间关键的查询。

- 不要在主键中指定太多或太长列，因为这些列值在每个辅助索引中重复。当索引包含不必要的数据时，读取该数据的I/O和缓存该数据的内存会降低服务器的性能和可伸缩性。

- 不要为每个列创建单独的辅助索引，因为每个查询只能使用一个索引。很少测试的列或只有几个不同值的列上的索引可能对任何查询都没有帮助。如果对同一个表有很多查询，测试不同的列组合，请尝试创建少量的连接索引，而不是大量的单列索引。如果索引包含结果集所需的所有列(称为覆盖索引)，查询可能完全能够避免读取表数据。

- 如果索引列不能包含任何`NULL`值，请在创建表时将其声明为`NOT NULL`。优化程序可以更好地确定哪个索引最适合用于查询知道每列是否包含`NULL`值。

- 您可以为InnoDB表优化单查询事务


## 4.7 优化InnoDB DDL操作

表和索引上的许多`DDL`操作(`CREATE`、`ALTER`和`DROP`语句)都可以在线执行。

在线DDL对添加辅助索引的支持意味着，通过创建没有辅助索引的表，然后在加载数据之后添加辅助索引，通常可以加快创建和加载表以及相关索引的过程。

使用`TRUNCATE TABLE`清空表，而不是`DELETE FROM tbl_name`。 外键约束可以使`TRUNCATE`语句像常规`DELETE`语句一样工作，在这种情况下，像`DROP TABLE`和`CREATE TABLE`这样的命令序列可能是最快的。

因为主键是每个`InnoDB`表的存储布局的组成部分，并且更改主键的定义涉及重新组织整个表，所以始终将主键设置为`CREATE TABLE`语句的一部分，并提前计划，以便您之后不需要`ALTER`或`DROP`主键。


## 4.8 优化InnoDB磁盘I/O

如果遵循数据库设计和SQL操作调优技术的最佳实践，但是由于磁盘I/O活动频繁，数据库仍然很慢，请考虑这些磁盘I/O优化。如果Unix `top`工具或Windows任务管理器显示工作负载的CPU使用率低于70%，那么工作负载可能是磁盘限制的。

- 增加 buffer pool大小
当表数据缓存在`InnoDB`缓冲池中时，查询可以重复访问它，而不需要任何磁盘I/O。使用`innodb_buffer_pool_size`选项指定缓冲池的大小。这个内存区域非常重要，通常建议将`innodb_buffer_pool_size`配置为系统内存的50%到75%。

- 调整flush method
在GNU/Linux和Unix的某些版本中，使用Unix `fsync()`调用（`InnoDB`默认使用）和类似方法将文件刷新到磁盘的速度非常慢。如果数据库写入性能存在问题，请将`innodb_flush_method`参数设置为`O_DSYNC`进行基准测试。

- 在Linux上使用带有本机AIO的noop或deadline I/O调度程序

`InnoDB`使用Linux上的异步I/O子系统（本机AIO）来执行数据文件页面的预读和写入请求。 此行为由`innodb_use_native_aio`配置选项控制，该选项默认启用。 对于本机AIO，I/O调度程序的类型对I/O性能的影响更大。 通常，建议使用`noop`和`deadline` I/O调度程序。 执行基准测试以确定哪个I/O调度程序为您的工作负载和环境提供最佳结果。

- 在Solaris 10上为x86_64体系结构使用直接I/O

在Solaris 10 for x86_64体系结构（AMD Opteron）上使用`InnoDB`存储引擎时，请对`InnoDB`相关文件使用直接I/O，以避免`InnoDB`性能下降。 要将直接I/O用于存储`InnoDB`相关文件的整个`UFS`文件系统，请使用`forcedirectio`选项挂载它; 请参阅mount_ufs（1M）。 （Solaris 10 / x86_64上的缺省值不使用此选项。）仅将直接I/O应用于`InnoDB`文件操作而不是整个文件系统，请设置`innodb_flush_method = O_DIRECT`。 使用此设置，InnoDB为数据文件的I/O调用`directio()`而不是`fcntl()`（而不是I/O到日志文件）。


- 使用Solaris 2.6或更高版本的数据和日志文件的原始存储

在任何版本的Solaris 2.6及更高版本和任何平台（sparc / x86 / x64 / amd64）上使用InnoDB存储引擎和`innodb_buffer_pool_size`值时，在原始设备或单独的直接I上使用InnoDB数据文件和日志文件进行基准测试 I/O UFS文件系统，使用前面描述的`forcedirectio`挂载选项。 （如果希望直接对日志文件进行I/O，则必须使用mount选项而不是设置`innodb_flush_method`。）Veritas文件系统VxFS的用户应使用`convosync = direct mount`选项。

不要将其他MySQL数据文件（例如MyISAM表的数据文件）放在直接I/O文件系统上。不得将可执行文件或库放在直接I/O文件系统上。

- 使用额外的存储设备

可以使用其他存储设备来设置`RAID`配置。

或者，InnoDB表空间数据文件和日志文件可以放在不同的物理磁盘上。

- 考虑non-rotational存储

---

非旋转存储通常为随机I/O操作提供更好的性能; 和用于顺序I/O操作的旋转存储。 在旋转和非旋转存储设备之间分发数据和日志文件时，请考虑主要在每个文件上执行的I/O操作的类型。

随机面向I/ o的文件通常包括每个表的文件和一般表空间数据文件、撤消表空间文件和临时表空间文件。顺序的面向I/O的文件包括InnoDB系统表空间文件(由于双重写缓冲和更改缓冲)和日志文件，如二进制日志文件和重做日志文件。


使用非旋转存储时，请检查以下配置选项的设置:

-  innodb_checksum_algorithm

crc32选项使用更快的校验和算法，建议用于快速存储系统。

- innodb_flush_neighbors

此选项可优化旋转存储设备的I/O. 禁用它用于非旋转存储或混合旋转和非旋转存储。

- innodb_io_capacity

默认设置200通常足以用于低端非旋转存储设备。 对于更高端的总线连接设备，请考虑更高的设置，例如1000。

-  innodb_io_capacity_max

默认值2000适用于使用非旋转存储的工作负载。 对于高端，总线连接的非旋转存储设备，请考虑更高的设置，例如2500。

-  innodb_log_compressed_pages

如果重做日志位于非旋转存储上，请考虑禁用此选项以减少日志记录。

-  innodb_log_file_size

如果重做日志位于非旋转存储上，则配置此选项以最大化缓存和写入组合。

-  innodb_page_size

考虑使用与磁盘内部扇区大小匹配的页面大小。早期的SSD设备的扇区大小通常为4KB。一些较新的设备扇区大小为16KB。默认的`InnoDB`页面大小是16KB。将页面大小保持在存储设备块大小附近，可以将重写到磁盘的未更改数据量降到最低。

-  binlog_row_image

如果二进制日志位于非旋转存储上且所有表都具有主键，请考虑将此选项设置为`minimal`以减少日志记录。

---

确保为您的操作系统启用了TRIM支持。它通常是默认启用的。

---

- 增加I/O容量以避免积压

如果吞吐量因`InnoDB`检查点操作而周期性下降，请考虑增加`innodb_io_capacity`配置选项的值。较高的值会导致更频繁的刷新，从而避免可能导致吞吐量下降的工作积压。

- 如果刷新不落后，则I/O容量会降低( Lower I/O capacity if flushing does not fall behind)

如果系统没有落后于`InnoDB`刷新操作，可以考虑降低`innodb_io_capacity`配置选项的值。通常，将此选项值保持为尽可能低的实用值，但不要低到导致吞吐量周期性下降的程度，如上一节所述。在一个可以降低选项值的典型场景中，您可能会在`SHOW ENGINE INNODB STATUS`的输出中看到这样的组合:

1. 历史列表长度低，低于几千。( History list length low, below a few thousand.)

2. 插入缓冲区合并靠近插入的行。

3. 缓冲池中的已修改页面始终低于缓冲池的`innodb_max_dirty_pages_pct`。 （在服务器未进行批量插入时进行测量;在批量插入期间，修改后的页面百分比显着上升是正常的。）

4. 日志序列号-最后一个检查点小于7/8或理想情况下小于InnoDB日志文件总大小的6/8。

5. 在Fusion-io设备上存储系统表空间文件

通过在支持原子写入的Fusion-io设备上存储系统表空间文件(“`ibdata`文件”)，可以利用与双写缓冲区相关的I/O优化。在本例中，双写缓冲(`innodb_doublewrite`)被自动禁用，所有数据文件都使用Fusion-io原子写。该特性仅在Fusion-io硬件上受支持，并且仅在Linux上为Fusion-io NVMFS启用。为了充分利用这个特性，建议使用`O_DIRECT`的`innodb_flush_method`设置。

`注意`
因为双写缓冲区设置是全局的，所以对于驻留在非fusion -io硬件上的数据文件也禁用双写缓冲。
`注意`

- 禁用压缩页面的记录

使用`InnoDB`表压缩功能时，在对压缩数据进行更改时，会将重新压缩页面的图像写入重做日志。 此行为由`innodb_log_compressed_pages`控制，默认情况下会启用该脚本以防止在恢复期间使用不同版本的zlib压缩算法时可能发生的损坏。 如果您确定`zlib`版本不会更改，请禁用`innodb_log_compressed_pages`以减少修改压缩数据的工作负载的重做日志生成。


## 4.9 优化InnoDB配置变量

对于具有轻量，可预测负载的服务器而言，不同的设置最适用于始终满负荷运行的服务器，或者遇到高活动高峰的服务器。

因为InnoDB存储引擎会自动执行许多优化，所以许多性能调优任务都包括监视以确保数据库运行良好，以及在性能下降时更改配置选项。

您可以执行的主要配置步骤包括:

- 使InnoDB能够在包含它们的系统上使用高性能内存分配器。

- 控制InnoDB缓冲已更改数据的数据更改操作的类型，以避免频繁的小磁盘写操作。参见配置更改缓冲。因为默认值是缓冲所有类型的数据更改操作，所以只有在需要减少缓冲量时才更改此设置。

- 使用`innodb_adaptive_hash_index`选项打开和关闭自适应哈希索引特性。您可以在异常活动期间更改此设置，然后将其还原为原始设置。

- 如果上下文切换是瓶颈，则设置InnoDB处理的并发线程数量的限制。

- 控制`InnoDB`通过预读操作所做的预取量。当系统有未使用的I/O容量时，更多的提前读取可以提高查询的性能。在负载过重的系统上，过多的预读会导致性能的周期性下降。

- 如果您有一个未被默认值充分利用的高端I/O子系统，则增加读取或写入操作的后台线程数。

- 控制I/O InnoDB在后台执行的数量。如果观察到性能的周期性下降，可以缩小此设置。

- 控制决定InnoDB何时执行某些类型的后台写操作的算法。该算法适用于某些类型的工作负载，但不适用于其他类型的工作负载，因此，如果您观察到性能的周期性下降，可能会关闭此设置。

- 利用多核处理器及其高速缓存内存配置，以最小化上下文切换中的延迟。

- 防止表扫描等一次性操作干扰存储在`InnoDB`缓冲区缓存中的频繁访问数据。

- 将日志文件调整为对可靠性和崩溃恢复有意义的大小。 InnoDB日志文件通常保持较小，以避免崩溃后的长启动时间。 MySQL中引入的优化5.5加快崩溃恢复过程的某些步骤。 特别是，由于改进了内存管理算法，扫描重做日志和应用重做日志的速度更快。 如果您将日志文件人为地缩小以避免长启动时间，则现在可以考虑增加日志文件大小以减少由于重做日志记录的回收而发生的I / O.

- 配置InnoDB缓冲池的实例大小和数量，对于具有多千兆字节缓冲池的系统尤为重要。

- 增加并发事务的最大数量，这极大地提高了最繁忙数据库的可伸缩性。

- 将清除操作(垃圾收集的一种类型)移动到后台线程。要有效地度量此设置的结果，首先调优其他与I/ o和线程相关的配置设置。

- 减少InnoDB在并发线程之间的切换量繁忙服务器上的SQL操作不会排队并形成“交通阻塞”。为`innodb_thread_concurrency`选项设置一个值，对于高性能的现代系统，最多约为32。将innodb_concurrency_tickets选项的值增加到5000左右。这些选项的组合为InnoDB每次处理的线程数量设置了一个上限，并允许每个线程在被交换出去之前做大量的工作，这样等待的线程数量就会保持在较低的水平，操作可以在没有过多上下文切换的情况下完成。

## 4.10 为具有多个表的系统优化InnoDB

如果您配置了非持久优化器统计信息（非默认配置），InnoDB会在启动后第一次访问该表时计算表的索引基数值，而不是在表中存储这些值。 对于将数据分区为多个表的系统，此步骤可能会花费大量时间。 由于此开销仅适用于初始表打开操作，要“预热”表以供以后使用，请在启动后立即通过发出`SELECT 1 FROM tbl_name LIMIT 1`等语句来访问它。

优化器统计信息在默认情况下被持久化到磁盘，这是由`innodb_stats_persistent`配置选项启用的。


# MYISAM,MEMORY 引擎优化 跳过......................






