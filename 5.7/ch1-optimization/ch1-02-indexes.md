# 索引优化

提高`SELECT`操作性能的最佳方法是在查询中测试的一个或多个列上创建索引。索引条目的作用类似于表行的指针，允许查询快速确定哪些行与`WHERE`子句中的条件匹配，并检索这些行的其他列值。 可以索引所有MySQL数据类型。

尽管为查询中使用的每一列创建索引很有吸引力，但是不必要的索引会浪费MySQL确定使用哪些索引的空间和时间。索引还会增加插入、更新和删除的成本，因为必须更新每个索引。您必须找到正确的平衡，才能使用最优索引集实现快速查询

## 2.1 MySQL如何使用索引

索引用于快速查找具有特定列值的行。如果没有索引，MySQL必须从第一行开始，然后遍历整个表来找到相关的行。表越大，花费越多。如果表中有相关列的索引，MySQL可以快速确定要查找的位置，而不需要查看所有数据。这比按顺序读取每一行要快得多。

大多数MySQL索引(`PRIMARY KEY`, `UNIQUE`, `INDEX`, 和 `FULLTEXT`)都存储在`B-trees`中。例外：`空间数据类型`的索引使用 `R-trees`; `MEMORY`表也支持`hash indexes`; `InnoDB`对`FULLTEXT`索引使用 `inverted lists`。

一般来说，索引的使用方法如下所述。

MySQL使用索引进行这些操作：

- 快速查找匹配WHERE子句的行。
- 消除行的考虑。 如果在多个索引之间有选择，MySQL通常使用找到最小行数（最具选择性的索引）的索引。
- 如果表具有多列索引，优化器可以使用索引的任何最左前缀来查找行。例如，如果您对`(col1, col2, col3)`有一个三列索引，那么您就可以对`(col1)`、`(col1, col2)`和`(col1, col2, col3)`有索引搜索功能。
- 在执行联接时从其他表检索行。如果将列声明为相同的类型和大小，MySQL可以更有效地使用列上的索引。在这个上下文中，如果`VARCHAR`和`CHAR`被声明为相同的大小，那么它们就被认为是相同的。例如，`VARCHAR(10)`和`CHAR(10)`大小相同，但是`VARCHAR(10)`和`CHAR(15)`大小不同。

对于非二进制字符串列之间的比较，两列应该使用相同的字符集。例如，将`utf8`列与`latin1`列进行比较，就不能使用索引。

如果在不进行转换的情况下不能直接比较值，那么比较不同的列(例如，将字符串列与时态列或数字列进行比较)可能会阻止使用索引。对于数值列中的给定值(如`1`)，它可能与字符串列中的任意数量的值(如`'1'`、`'1'`、`'00001'`或`'01.e1'`)进行比较。这排除了对字符串列使用任何索引。

- 查找特定索引列`key_col`的`MIN()`或`MAX()`值。是由预处理程序优化的，它检查您是否对索引中`key_col`之前的所有关键部分使用`WHERE key_part_N = constant`。在本例中，MySQL为每个键执行一个键查找表达式，并用常量替换它。如果所有表达式都替换为常量，查询将立即返回。例如:
```mysql
SELECT MIN(key_part2),MAX(key_part2)
FROM tbl_name WHERE key_part1=10;
```

- 对表进行排序或分组，如果排序或分组是在可用索引的最左前缀上完成的(例如，按`key_part1`、`key_part2`排序)。如果所有关键部件后面都跟着`DESC`，则按相反的顺序读取键。

- 在某些情况下，可以优化查询来检索值，而不需要查询数据行。(为查询提供所有必要结果的索引称为覆盖索引。)如果查询只从表中使用某些索引中包含的列，则可以从索引树中检索所选的值，以获得更快的速度:
```mysql
SELECT key_part3 FROM tbl_name
WHERE key_part1=1
```

索引对于小表或报表查询处理大部分或所有行的大表上的查询不那么重要。当查询需要访问大多数行时，按顺序读取要比遍历索引快。顺序读取最小化磁盘查找，即使查询不需要所有行。


### 2.1.1 Primary Key优化

表的主键表示在最重要的查询中使用的列或列集。它有一个关联索引，用于快速查询性能。`NOT NULL`优化提高了查询性能，因为它不能包含任何`NULL`值。使用`InnoDB`存储引擎，表数据被物理组织起来，可以根据主键列或多个列进行超高速查找和排序。

如果您的表很大很重要，但是没有一个明显的列或一组列可以用作主键，那么您可以创建一个单独的列，其中包含自动递增的值作为主键。当使用外键连接表时，这些惟一IDS可以作为指向其他表中相应行的指针。

### 2.1.2 Foreign Key优化

如果一个表有很多列,你查询列的许多不同的组合,这可能是有效较少用到的数据分割成独立的表有几列,和与他们回到主表表从主复制数字ID列。这样，每个小表都可以有一个主键来快速查找其数据，并且可以使用join操作查询所需的一组列。根据数据的分布方式，查询可能会执行较少的I / O并占用较少的高速缓存，因为相关列在磁盘上打包在一起。(为了最大化性能，查询尝试从磁盘读取尽可能少的数据块;只有几列的表可以在每个数据块中容纳更多的行。)

### 2.1.3 列索引(Column Indexes)

最常见的索引类型涉及单个列，将该列中的值的副本存储在数据结构中，允许快速查找具有相应列值的行。

B-tree数据结构允许索引在`WHERE`子句中快速找到一个特定的值、一组值或一组值，这些值对应于`=`、`>`、`≤`、`BETWEEN`、`IN`等操作符。

每个表的最大索引数和最大索引长度是由每个存储引擎定义的。所有存储引擎都支持每个表至少16个索引和至少256字节的索引长度。大多数存储引擎都有更高的限制。

#### 2.1.3.1 索引前缀(Index Prefixes)

在字符串列的索引规范中使用`col_name(N)`语法，可以创建只使用列的前`N`个字符的索引。以这种方式只索引列值的前缀可以使索引文件小得多。为`BLOB`或`TEXT`列建立索引时，必须为索引指定前缀长度。例如:
```mysql
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
```

前缀可以长达1000字节(对于`InnoDB`表，除非设置了`innodb_large_prefix`集，否则为767字节)。

`注意：`
前缀限制以字节为单位，而`CREATE TABLE`，`ALTER TABLE`和`CREATE INDEX`语句中的前缀长度被解释为非二进制字符串类型（`CHAR`，`VARCHAR`，`TEXT`）的字符数和二进制字符串类型的字节数（`BINARY`， `VARBINARY`，`BLOB`）。在为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑这一点。

---
如果搜索项超过索引前缀长度，则使用索引排除不匹配的行，并检查其余行是否匹配。

#### 2.1.3.2 全文索引(FULLTEXT Indexes)

全文索引用于`FULLTEXT`。只有`InnoDB`和`MyISAM`存储引擎支持`FULLTEXT`，而且只支持`CHAR`、`VARCHAR`和`TEXT`列。索引总是在整个列上执行，不支持列前缀索引。

优化应用于针对单个`InnoDB`表的某些类型的`FULLTEXT`查询。具有这些特征的查询特别有效:

- 只返回文档ID或文档ID和搜索级别的`FULLTEXT`查询。
- `FULLTEXT`按分数降序对匹配行进行排序，并应用`LIMIT`子句获取匹配行的前N行。要应用这种优化，必须没有`WHERE`子句，并且只有一个降序的`ORDER BY`子句。
- `FULLTEXT`查询仅检索与搜索词匹配的行的`COUNT(*)`值，而没有其他`WHERE`子句。 将WHERE子句编码为`WHERE MATCH(text) AGAINST ('other_text')`，不带任何`> 0`比较运算符。

对于包含全文表达式的查询，MySQL在查询执行的优化阶段计算这些表达式。优化器不只是查看全文表达式并进行估计，它实际上是在开发执行计划的过程中评估它们。

这种行为的一个含义是，`EXPLAIN` for全文查询通常比非全文查询慢，后者在优化阶段没有对表达式求值。

由于优化期间发生匹配，全文查询的`EXPLAIN`可能会在`Extra`列中显示`Select tables optimized away`; 在这种情况下，在以后的执行期间不需要访问表。


#### 2.1.3.3 空间索引(Spatial Indexes)

您可以在空间数据类型上创建索引。`MyISAM`和`InnoDB`支持空间类型的`R-tree`索引。其他存储引擎使用b树对空间类型进行索引(`ARCHIVE`除外，存档不支持空间类型索引)。

#### 2.1.3.4 内存存储引擎中的索引(Indexes in the MEMORY Storage Engine)

`MEMORY`存储引擎默认使用`HASH`索引，但也支持`BTREE`索引。

### 2.1.4 多列索引(Multiple-Column Indexes)

MySQL可以创建复合索引(即多个列上的索引)。索引最多可以由16列组成。对于某些数据类型，可以索引列的前缀。

MySQL可以对测试索引中所有列的查询使用多列索引，或者只测试第一列，前两列，前三列等的查询。 如果你指定在索引定义中以正确顺序排列的列，单个复合索引可以加速同一个表上的几种查询。

多列索引可以看作是一个排序数组，其中的行包含通过连接索引列的值创建的值。

















