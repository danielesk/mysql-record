# 数据库结构优化

在您作为数据库设计者的角色中，寻找最有效的方式去管理你的schemas、tables和columns。与调优应用程序代码时一样，您将最小化I/O，将相关项放在一起，并提前计划，以便随着数据量的增加性能保持较高。从高效的数据库设计开始，团队成员可以更轻松地编写高性能的应用程序代码，并使数据库可以随着应用程序的发展和重写而持久。

## 3.1 优化数据大小(Optimizing Data Size)

设计您的表以最小化磁盘上的空间。通过减少写入和读取磁盘的数据量，这可以带来巨大的改进。较小的表通常需要较少的主内存，而其内容在查询执行期间被主动处理。 表数据的任何空间缩减也会导致较小的索引可以更快地处理。

MySQL支持许多不同的存储引擎(表类型)和行格式。对于每个表，您可以决定使用哪种存储和索引方法。为应用程序选择合适的表格式可以大大提高性能。

### 3.1.1 表列(Table Columns)

- 尽可能使用最有效(最小)的数据类型。MySQL有许多专门的类型可以节省磁盘空间和内存。例如，如果可能的话，使用较小的整数类型来获得较小的表。`MEDIUMINT`通常是比`INT`更好的选择，因为`MEDIUMINT`列使用的空间少25%。

- **如果可能，将列声明为`NOT NULL`。通过更好地使用索引和消除测试每个值是否为`NULL`的开销，它使SQL操作更快。** 您还节省了一些存储空间，每列一个位。如果您确实需要表中的`NULL`值，请使用它们。只要避免默认设置，即允许每一列中都有`NULL`值。

### 3.1.2 行格式(Row Format)

- 默认情况下，`InnoDB`表是使用`DYNAMIC`行格式创建的。要使用`DYNAMIC`以外的行格式，请配置`innodb_default_row_format`，或在`CREATE TABLE`或`ALTER TABLE`语句中显式指定`ROW_FORMAT`选项。

紧凑的行格式系列( `COMPACT`, `DYNAMIC` 和 `COMPRESSED`)减少了行存储空间，但代价是增加了某些操作的CPU使用量。如果您的工作负载是受缓存命中率和磁盘速度限制的典型工作负载，那么它可能会更快。如果受到CPU速度限制的情况很少见，那么可能会慢一些。

 当使用可变长度字符集（如`utf8mb3`或`utf8mb4`）时，紧凑的行格式系列还可优化`CHAR`列存储。当`ROW_FORMAT=REDUNDANT`，`CHAR(N)`占用了`N`×字符集的最大字节长度。许多语言主要可以使用单字节`utf8`字符来编写，因此固定的存储长度常常会浪费空间。借助紧凑的行格式系列，`InnoDB`在`N`到`N`的范围内分配可变数量的存储 × 这些列的字符集的最大字节长度 通过去除尾随空格。(With the compact family of rows formats, InnoDB allocates a variable amount of storage in the range of N to N
× the maximum byte length of the character set for these columns by stripping trailing spaces.)。最小存储长度为`N`字节，以方便在典型情况下进行就地更新。

- 若要通过以压缩形式存储表数据进一步减少空间，请指定`ROW_FORMAT=COMPRESSED`在创建`InnoDB`表时，或者在现有的`MyISAM`表上运行`myisampack`命令。(`InnoDB`压缩表是可读可写的，而`MyISAM`压缩表是只读的。)

- 对于`MyISAM`表，如果没有任何可变长度的列(`VARCHAR`、`TEXT`或`BLOB`列)，则使用固定大小的行格式。这更快，但可能会浪费一些空间。您可以使用`CREATE TABLE`选项`ROW_FORMAT= FIXED`提示您希望有固定长度的行，即使您有`VARCHAR`列。

### 3.1.3 索引(Indexes)

- 表的主索引应该尽可能短。这使得每一行的标识简单而有效。对于`InnoDB`表，主键列在每个辅助索引条目中都是重复的，所以如果有很多辅助索引，那么短的主键可以节省大量空间。

- 只创建提高查询性能所需的索引。索引很适合检索，但是会降低插入和更新操作的速度。如果您主要通过搜索列的组合来访问表，请在这些列上创建单个复合索引，而不是为每个列创建单独的索引。索引的第一部分应该是最常用的列。如果在从表中选择时总是使用许多列，那么索引中的第一列应该是重复数最多的列，以获得更好的索引压缩。

- 如果长字符串列很可能在第一个字符数上有唯一的前缀，那么最好只索引此前缀，使用MySQL支持在列的最左边部分创建索引。更短的索引更快，这不仅是因为它们需要更少的磁盘空间，还因为它们在索引缓存中提供了更多的命中，从而减少了磁盘查找。

### 3.1.4 连接(Joins)

- 在某些情况下，将一个经常被扫描的表分成两个是有益的。如果它是动态格式表，则尤其如此，并且可以使用较小的静态格式表，该表可用于在扫描表时查找相关行。

- 在具有相同数据类型的不同表中声明具有相同信息的列，以加快基于相应列的连接。

- 保持列名简单，以便可以在不同的表中使用相同的名称，并简化连接查询。例如，在名为`customer`的表中，使用`name`的列名而不是`customer_name`。要使您的名称可移植到其他SQL服务器，请考虑将它们保持在18个字符以下。


### 3.1.5 标准化(Normalization)

- 通常情况下，尽量保持所有数据无冗余(观察数据库理论中所说的第三种范式)。不要重复冗长的值，如名称和地址，而是为它们分配惟一的id，根据需要跨多个较小的表重复这些id，并通过在join子句中引用id在查询中联接表。

- 如果速度比磁盘空间和保存多个数据副本的维护成本更重要，例如在业务智能场景中，您可以分析来自大型表的所有数据，那么您可以放松规范化规则、复制信息或创建汇总表来获得更快的速度。


## 3.2 优化MySQL数据类型(Optimizing MySQL Data Types)

### 3.2.1 数据数值优化(Optimizing for Numeric Data)

- 对于惟一id或其他可以表示为字符串或数字的值，请选择数字列而不是字符串列。由于大的数值比相应的字符串存储在更少的字节中，因此传输和比较它们更快，占用更少的内存。

- 如果使用数字数据，在许多情况下，从数据库(使用活动连接)访问信息比访问文本文件更快。数据库中的信息可能以比文本文件更紧凑的格式存储，因此访问它需要更少的磁盘访问。还可以在应用程序中保存代码，因为可以避免解析文本文件来查找行和列边界。


### 3.2.2 优化字符和字符串类型(Optimizing for Character and String Types)

对于字符和字符串列，请遵循以下准则:

- 如果不需要特定于语言的排序功能，请使用二进制排序顺序进行快速比较和排序操作。可以使用`BINARY`操作符在特定查询中使用二进制排序规则。

- 在比较来自不同列的值时，尽可能使用相同的字符集和排序规则声明这些列，以避免在运行查询时发生字符串转换。

- 对于小于`8KB`的列值，使用二进制`VARCHAR`而不是`BLOB`。`GROUP BY`和`ORDER BY`子句可以生成临时表，如果原始表不包含任何`BLOB`列，这些临时表可以使用MEMORY存储引擎。

- 如果一个表包含字符串列，如name和address，但是许多查询不检索这些列，则考虑将字符串列拆分为一个单独的表，并在必要时使用带有外键的join查询。当MySQL从一行中检索任何值时，它将读取一个数据块，其中包含该行的所有列(可能还有其他相邻行)。保持每行小，只使用最常用的列，可以在每个数据块中容纳更多的行。这种紧凑表减少了常见查询的磁盘I/O和内存使用量。

- 当您在InnoDB表中使用一个随机生成的值作为主键时，如果可能的话，在它前面加上一个升序值，比如当前日期和时间。当连续的主值物理存储在彼此附近时，InnoDB可以更快地插入和检索它们。


### 3.2.3 BLOB类型的优化(Optimizing for BLOB Types)

- 当存储包含文本数据的大型blob时，首先考虑压缩它。当整个表被InnoDB或MyISAM压缩时，不要使用这种技术。

- 对于具有多个列的表，要减少不使用BLOB列的查询的内存要求，请考虑将BLOB列拆分为单独的表，并在需要时使用连接查询引用它。

- 由于检索和显示BLOB值的性能要求可能与其他数据类型非常不同，所以可以将BLOB特定的表放在不同的存储设备上，甚至是单独的数据库实例上。例如，要检索BLOB可能需要大量的顺序磁盘读取，这更适合于传统硬盘驱动器而不是SSD设备。

- 您可以将列值的哈希值存储在单独的列中，索引该列，并在查询中测试哈希值，而不是针对非常长的文本字符串测试相等性。(使用MD5()或CRC32()函数来生成散列值。)由于哈希函数可以为不同的输入生成重复的结果，所以查询中仍然包含一个子句和`blob_column = long_string_value`，以防止错误匹配;性能优势来自较小的、易于扫描的散列值索引。


### 3.2.4 使用过程分析(Using PROCEDURE ANALYSE)

`ANALYSE([max_elements[,max_memory]])`

`注意：过程分析()在MySQL 5.7.18中被弃用，并被删除MySQL 8.0。`

..................

## 3.3 多张表的优化(Optimizing for Many Tables)

保持单个查询速度的一些技术包括跨多个表拆分数据。当表的数量达到数千甚至数百万时，处理所有这些表的开销就成为一个新的性能考虑因素。

### 3.3.1 MySQL如何打开和关闭表

执行`mysqladmin status`命令时，应该会看到如下内容:

```mysql
Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
```

如果您有少于12个表，那么`Open tables`值12可能有些令人费解。

MySQL是多线程的，因此可能有许多客户端同时对给定的表发出查询。为了最小化多个客户机会话在同一个表上具有不同状态的问题，每个并发会话独立地打开该表。这将使用额外的内存，但通常会提高性能。对于`MyISAM`表，对于打开该表的每个客户机，数据文件都需要一个额外的文件描述符。(相反，索引文件描述符在所有会话之间共享。)

`table_open_cache`和`max_connections`系统变量影响服务器保持打开的文件的最大数量。如果增加其中一个或两个值，可能会遇到操作系统对每个进程打开的文件描述符数量施加的限制。许多操作系统允许您提高打开文件的限制，尽管方法因系统而异。参考您的操作系统文档，确定是否可以增加限制以及如何增加限制。

`table_open_cache`与`max_connections`相关。例如，对于200个并发运行的连接，指定至少`200 * N`的表缓存大小，其中`N`是您执行的任何查询中每个连接中表的最大数量。还必须为临时表和文件保留一些额外的文件描述符。

确保您的操作系统能够处理table_open_cache设置所暗示的打开文件描述符的数量。如果table_open_cache设置过高，MySQL可能会耗尽文件描述符，并出现拒绝连接或无法执行查询等症状。

还要考虑到，`MyISAM`存储引擎需要为每个惟一的打开表提供两个文件描述符。对于分区的`MyISAM`表，打开的表的每个分区都需要两个文件描述符。(当`MyISAM`打开一个分区表时，它会打开该表的每个分区，不管是否实际使用了给定的分区。：要增加MySQL可用的文件描述符的数量，请设置`open_files_limit`系统变量。

打开的表的缓存保存在`table_open_cache`条目的级别。服务器在启动时自动调整缓存大小。要显式设置大小，请在启动时设置`table_open_cache`系统变量。MySQL可能临时打开比这更多的表来执行查询，如本节后面所述。


MySQL关闭一个未使用的表，并在以下情况下从表缓存中删除它:

- 当缓存已满且线程试图打开不在缓存中的表时。

- 当缓存中包含超过`table_open_cache`条目且缓存中的表不再被任何线程使用时。

- 当执行表刷新操作时。当有人发出`FLUSH TABLES`语句或执行`mysqladmin flush-tables`或`mysqladmin refresh`命令时，就会发生这种情况。

当表缓存被填满时，服务器使用以下过程来定位要使用的缓存条目:

- 从最近最少使用的表开始，释放当前未使用的表。

- 如果必须打开一个新表，但是缓存已满，不能释放任何表，则根据需要临时扩展缓存。当缓存处于临时扩展状态，表从使用状态变为未使用状态时，表将被关闭并从缓存中释放。


为每个并发访问打开一个`MyISAM`表。这意味着，如果两个线程访问同一个表，或者一个线程在同一个查询中访问表两次(例如，通过将表连接到自身)，则需要打开表两次。每次并发打开都需要表缓存中的一个条目。任何`MyISAM`表的第一次打开都使用两个文件描述符:一个用于数据文件，另一个用于索引文件。表的每次额外使用只接受数据文件的一个文件描述符。索引文件描述符在所有线程之间共享。


如果使用处理程序`tbl_name OPEN`语句打开表，则为线程分配一个专用的表对象。这个表对象不会被其他线程共享，并且在线程调用处理程序`tbl_name CLOSE`或线程终止之前不会关闭。当这种情况发生时，表被放回表缓存中(如果缓存没有满)。

要确定表缓存是否太小，请检查`Opened_tables`状态变量，该变量指示自服务器启动以来打开表操作的数量:

```mysql
mysql> SHOW GLOBAL STATUS LIKE 'Opened_tables';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 2741  |
+---------------+-------+
```

如果值非常大或增长很快，即使没有发出很多`FLUSH TABLES`语句，也要在服务器启动时增加`table_open_cache`值。


### 3.3.2 在同一个数据库中创建多个表的缺点(Disadvantages of Creating Many Tables in the Same Database)

如果在同一个数据库目录中有许多`MyISAM`表，则打开、关闭和创建操作都很慢。如果您在许多不同的表上执行`SELECT`语句，那么当表缓存已满时，会有一点开销，因为对于必须打开的每个表，必须关闭另一个表。可以通过增加表缓存中允许的条目数量来减少这种开销。


## 3.4 MySQL内部临时表的使用

在某些情况下，服务器在处理语句时创建内部临时表。用户无法直接控制何时发生这种情况。

服务器在以下条件下创建临时表:

- 评估`UNION`语句，稍后描述一些例外。

- 评估某些视图，例如使用`TEMPTABLE`算法，`UNION`或聚合的视图。

- 对派生表( derived tables )的评估

- 为子查询或半连接实现创建的表

- 对包含`ORDER BY`子句和不同的`GROUP BY`子句的语句求值，或对`ORDER BY`或`GROUP BY`语句求值，其中`ORDER BY`或`GROUP BY`包含来自联接队列中第一个表之外的表的列。

- 评估`DISTINCT`结合`ORDER BY`可能需要临时表。

- 对于使用`SQL_SMALL_RESULT`修饰符的查询，MySQL使用内存中的临时表，除非查询还包含需要磁盘存储的元素（稍后描述）。

- 为了评估从同一个表中选择和插入的`INSERT ... SELECT`语句，MySQL创建了一个内部临时表来保存`SELECT`中的行，然后将这些行插入到目标表中。

- 评估多表`UPDATE`语句。

- 评估`GROUP_CONCAT()`或`COUNT(DISTINCT)`表达式。

要确定语句是否需要临时表，请使用EXPLAIN并检查Extra列以查看是否显示Using temporary。EXPLAIN不一定会说对派生的或物化的`Using temporary`使用临时表(EXPLAIN will not necessarily say Using temporary for derived or materialized  temporary tables.)。

当服务器创建一个内部临时表(无论是在内存中还是在磁盘上)时，它将递增`Created_tmp_tables`状态变量。如果服务器在磁盘上创建表(最初创建或转换内存中的表)，它将增加`Created_tmp_disk_tables`状态变量。

一些查询条件阻止使用内存中的临时表，在这种情况下，服务器使用磁盘上的表:

- 表中存在`BLOB`或`TEXT`。这包括具有字符串值的用户定义变量，因为它们分别被视为`BLOB`或`TEXT`，这取决于它们的值是二进制字符串还是非二进制字符串。

- 如果使用`UNION`或`UNION ALL`，则选择列表中存在最大长度大于512(二进制字符串为字节，非二进制字符串为字符)的任何字符串列。

- `SHOW COLUMNS`和`DESCRIBE`语句使用`BLOB`作为某些列的类型，因此用于结果的临时表是磁盘表。


服务器不为满足某些条件的`UNION`语句使用临时表。相反，它只从临时表创建中保留执行结果列类型转换所需的数据结构。表没有完全实例化，也没有向其写入或读取行;行直接发送到客户机。其结果是减少了内存和磁盘的需求，并且第一行发送到客户机之前的延迟也更小，因为服务器不需要等到执行最后一个查询块。`EXPLAIN`和optimizer跟踪输出反映了这种执行策略:`UNION RESULT`查询块不存在，因为该块对应于从临时表中读取的部分。

这些条件使`UNION`无需临时表即可进行评估：

- union是UNION ALL，而不是UNION或UNION DISTINCT。

- 没有全局ORDER BY子句。

- `union`不是`{INSERT | REPLACE} ... SELECT ...`的顶级查询块声明。

### 3.4.1 内部临时表存储引擎

内部临时表可以保存在内存中，由内存存储引擎处理，或者由`InnoDB`或`MyISAM`存储引擎存储在磁盘上。

如果内部临时表作为内存表创建，但是变得太大，MySQL会自动将其转换为磁盘表。内存中临时表的最大大小由`tmp_table_size`或`max_heap_table_size`值定义，以较小的值为准。这与使用`CREATE TABLE`显式创建内存表不同。对于这样的表，只有`max_heap_table_size`变量决定表的大小，并且没有转换为磁盘格式。

`internal_tmp_disk_storage_engine`变量定义了服务器用来管理磁盘上的内部临时表的存储引擎。允许的值是`INNODB`(默认值)和`MYISAM`。

`注意`
当使用`internal_tmp_disk_storage_engine=INNODB`时，生成磁盘上超过`INNODB`行或列的内部临时表的查询会限制返回行大小过大或列错误太多的行。解决方法是将`internal_tmp_disk_storage_engine`设置为`MYISAM`。
`注意`

### 3.4.2 内部临时表存储格式

内存中的临时表由内存存储引擎管理，它使用固定长度的行格式。`VARCHAR`和`VARBINARY`列值被填充到最大的列长度，实际上将它们存储为`CHAR`和`BINARY`。

磁盘上的临时表由`InnoDB`或`MyISAM`存储引擎管理(取决于`internal_tmp_disk_storage_engine`设置)。两个引擎都使用动态宽度行格式存储临时表。列只占用所需的存储空间，与使用固定长度行的磁盘表相比，这减少了磁盘I/O、空间需求和处理时间。

对于最初在内存中创建内部临时表，然后将其转换为磁盘上的表的语句，可以跳过转换步骤，首先在磁盘上创建表，从而获得更好的性能。`big_tables`变量可用于强制内部临时表的磁盘存储。












