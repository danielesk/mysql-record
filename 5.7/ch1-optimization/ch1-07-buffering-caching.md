# 缓冲和缓存

MySQL使用几种策略在内存缓冲区中缓存信息以提高性能。

## 7.1 InnoDB缓冲池优化

`InnoDB`维护一个名为`buffer poll`的存储区域，用于在内存中缓存数据和索引。了解`InnoDB`缓冲池的工作原理，并利用它将经常访问的数据保存在内存中，这是MySQL调优的一个重要方面。

要了解InnoDB缓冲池的内部工作原理，请概述其LRU替换算法和一般配置信息。

## 7.2 MyISAM key 缓存

......

## 7.3 MySQL查询缓存

`注意`

查询缓存在MySQL 5.7.20中被弃用，并在MySQL中删除8.0。

直接跳过......

## 7.4 缓存准备好的语句和存储的程序

对于客户机可能在会话期间多次执行的某些语句，服务器将语句转换为内部结构并缓存该结构，以便在执行期间使用。缓存使服务器能够更有效地执行，因为它避免了在会话期间再次需要语句时重新转换语句的开销。转换和缓存发生在以下语句:

- 预处理语句，包括在SQL级别处理的语句(使用`PREPARE`语句)和使用二进制客户机/服务器协议处理的语句(使用`mysql_stmt_prepare()` C API函数)。max_prepared_stmt_count系统变量控制服务器缓存的语句总数。(所有会话中准备语句的总数。)

- 存储程序(存储过程和函数、触发器和事件)。在本例中，服务器转换并缓存整个程序体。`stored_program_cache`系统变量表示服务器在每个会话中缓存的存储程序的大致数量。

服务器在每个会话的基础上为准备好的语句和存储的程序维护缓存。为一个会话缓存的语句不能被其他会话访问。当会话结束时，服务器丢弃为它缓存的任何语句。

当服务器使用缓存的内部语句结构时，它必须注意该结构不会过期。语句使用的对象可能会发生元数据更改，导致当前对象定义与内部语句结构中表示的定义不匹配。DDL语句会发生元数据更改，比如那些创建、删除、更改、重命名或截断表的语句，或者分析、优化或修复表的语句。表内容更改(例如，使用`INSERT`或`UPDATE`)不会更改元数据，也不会更改`SELECT`语句。

这是这个问题的一个例子。假设客户端准备了以下语句:

```mysql
PREPARE s1 FROM 'SELECT * FROM t1';
```

`SELECT *`在内部结构中展开为表中的列列表。如果使用`ALTER table`修改表中的一组列，则准备好的语句将过期。如果服务器在客户机下一次执行`s1`时没有检测到这种更改，那么准备好的语句将返回不正确的结果。

为了避免对准备好的语句引用的表或视图的元数据更改造成的问题，服务器检测这些更改并在下一次执行语句时自动重新准备语句。也就是说，服务器修复语句并重新构建内部结构。在从表定义缓存中刷新引用的表或视图之后，也会发生重新解析，或者隐式地为缓存中的新条目腾出空间，或者显式地为` FLUSH TABLES`腾出空间。

类似地，如果存储程序使用的对象发生更改，服务器将修复程序中受影响的语句。

服务器还检测表达式中对象的元数据更改。这些语句可能用于特定于存储程序的语句中，比如`DECLARE CURSOR`或`flow-control`语句，比如`IF、CASE`和`RETURN`。

为了避免重新解析整个存储的程序，服务器仅在需要时才在程序中修复受影响的语句或表达式。例子:

- 假设表或视图的元数据发生了更改。对访问表或视图的程序中的`SELECT *`进行重新解析，但对不访问表或视图的`SELECT *`不进行重新解析。

- 当语句受到影响时，服务器仅在可能的情况下对其进行部分修复。考虑这个案例陈述:

```mysql
CASE case_expr
    WHEN when_expr1 ...
    WHEN when_expr2 ...
    WHEN when_expr3 ...
    ...
END CASE
```
如果元数据更改仅在`WHEN_expr3`时影响该表达式，则对该表达式进行修复。`case_expr`和另一个`when`表达式不被修复时。

重新解析使用默认数据库和SQL模式，这些模式在将原始表单转换为内部表单时有效。

服务器最多尝试重新解析三次。如果所有尝试都失败，就会发生错误。

重新解析是自动的，但是在一定程度上，重新解析会降低准备好的语句和存储的程序性能。

对于准备好的语句，`Com_stmt_reprepare`状态变量跟踪准备的数量。




